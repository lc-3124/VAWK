#include "core/enable_entity_shared_from_this.hpp"
#include "core/entity_Sptr.hpp"
#include "core/entity_Wptr.hpp"
#include <stdexcept>

namespace va {
// 构造：初始化 weak_this_ 为 nullptr
enable_entity_shared_from_this::enable_entity_shared_from_this() noexcept
    : weak_this_(nullptr) {}

enable_entity_shared_from_this::enable_entity_shared_from_this(const enable_entity_shared_from_this&) noexcept
    : weak_this_(nullptr) {}  // 拷贝时不复制 weak_this_（避免多个实例共享）

enable_entity_shared_from_this& enable_entity_shared_from_this::operator=(const enable_entity_shared_from_this&) noexcept {
    return *this;  // 赋值时不修改 weak_this_
}

// 析构：释放 weak_this_ 指针（避免内存泄漏）
enable_entity_shared_from_this::~enable_entity_shared_from_this() noexcept {
    delete weak_this_;
}

// 返回自身强指针：通过 weak_this_ 锁定
entity_Sptr enable_entity_shared_from_this::Sptr_from_this() {
    if (weak_this_ == nullptr) {
        throw std::runtime_error("enable_entity_shared_from_this: not managed by entity_Sptr");
    }
    entity_Sptr locked = weak_this_->lock();
    if (!locked) {
        throw std::runtime_error("enable_entity_shared_from_this: entity already destroyed");
    }
    return locked;
}

// 返回自身弱指针：返回 weak_this_ 的拷贝
entity_Wptr enable_entity_shared_from_this::Wptr_from_this() const {
    if (weak_this_ == nullptr) {
        throw std::runtime_error("enable_entity_shared_from_this: not managed by entity_Sptr");
    }
    return *weak_this_;
}
}  // namespace va

#include "core/EntityControlBlock.hpp"
// 在这里包含 VaEntity 完整定义（.cpp 层面，无依赖问题）
#include "core/VaEntity.hpp"

#include <iostream>

namespace va {
// 构造：强引用初始化为1，弱引用初始化为1（控制块自身持有1个弱引用）
EntityControlBlock::EntityControlBlock(VaEntity* entity)
    : entity_(entity), strong_cnt_(1), weak_cnt_(1) {
    assert(entity != nullptr && "Entity cannot be null (use empty entity_Sptr instead)");
}

// EntityControlBlock.cpp 中修改析构函数
EntityControlBlock::~EntityControlBlock() {
    std::lock_guard<std::mutex> lock(mutex_);
    if (entity_ != nullptr) {
        std::cerr << "[WARNING] Entity not destroyed before control block (fallback destroy)" << std::endl;
        // 处理 Raii() 异常，避免中断 delete
        try {
            entity_->Raii();
        } catch (const std::exception& e) {
            std::cerr << "[ERROR] Exception in entity Raii(): " << e.what() << std::endl;
        }
        // 无论是否异常，都要销毁实体并置空（避免双重释放）
        delete entity_;
        entity_ = nullptr;
    }
    assert(entity_ == nullptr && "Entity not destroyed before control block");
}


// 强引用 +1（线程安全，relaxed 内存序足够，无依赖）
void EntityControlBlock::increment_strong() {
    strong_cnt_.fetch_add(1, std::memory_order_relaxed);
}

// 强引用 -1（acq_rel 内存序：确保前序操作可见，后续操作不重排）
bool EntityControlBlock::decrement_strong() {
    if (strong_cnt_.fetch_sub(1, std::memory_order_seq_cst) == 1) {
        return true;  // 强引用归零
    }
    return false;
}

// 弱引用 +1（relaxed 内存序）
void EntityControlBlock::increment_weak() {
    weak_cnt_.fetch_add(1, std::memory_order_relaxed);
}

// 弱引用 -1（acq_rel 内存序）
bool EntityControlBlock::decrement_weak() {
    if (weak_cnt_.fetch_sub(1, std::memory_order_seq_cst) == 1) {
        return true;  // 弱引用归零
    }
    return false;
}

// 获取强引用计数（acquire 内存序：确保计数最新）
size_t EntityControlBlock::strong_count() const {
    return strong_cnt_.load(std::memory_order_acquire);
}

// 获取弱引用计数（acquire 内存序）
size_t EntityControlBlock::weak_count() const {
    return weak_cnt_.load(std::memory_order_acquire);
}

// 检查实体是否存活（强引用 > 0）
bool EntityControlBlock::is_alive() const {
    return strong_count() > 0;
}

// 线程安全获取实体指针（加锁防止析构时访问）
VaEntity* EntityControlBlock::get_entity() const {
    std::lock_guard<std::mutex> lock(mutex_);
    return is_alive() ? entity_ : nullptr;
}

// 销毁实体（仅强引用归零后调用）
void EntityControlBlock::destroy_entity() {
    std::lock_guard<std::mutex> lock(mutex_);
    if (entity_) {
        // 调用 VaEntity 的资源清理方法（若有）
        entity_->Raii();
        delete entity_;
        entity_ = nullptr;  // 标记实体已销毁
    }
}
}  // namespace va

#include "core/entity_Sptr.hpp"
#include "core/entity_Wptr.hpp"  // 后续实现弱指针后添加
#include "core/VaEntity.hpp"

namespace va {
// entity_Sptr.cpp 中修改构造函数
entity_Sptr::entity_Sptr(VaEntity* entity) : control_block_(nullptr) {
    if (entity == nullptr) return;

    control_block_ = new EntityControlBlock(entity);
    auto shared_base = dynamic_cast<enable_entity_shared_from_this*>(entity);
    if (shared_base != nullptr) {
        // 安全初始化：先释放旧指针（即使为 nullptr，delete 也安全）
        delete shared_base->weak_this_;
        // 确保 new 成功（若内存不足，会抛出 bad_alloc，避免空指针）
        shared_base->weak_this_ = new entity_Wptr(*this);
    }
}

// 拷贝构造：强引用 +1
entity_Sptr::entity_Sptr(const entity_Sptr& other) : control_block_(other.control_block_) {
    if (control_block_ != nullptr) {
        control_block_->increment_strong();
    }
}

// 移动构造：窃取所有权，原指针置空
entity_Sptr::entity_Sptr(entity_Sptr&& other) noexcept : control_block_(other.control_block_) {
    other.control_block_ = nullptr;
}

entity_Sptr::entity_Sptr(const entity_Wptr& weak) : control_block_(nullptr) {
    if (!weak.expired()) {
        control_block_ = weak.control_block_;
        control_block_->increment_strong();  // 强引用 +1
    }
}


// 内部构造：从控制块构造（供弱指针 lock() 使用）
entity_Sptr::entity_Sptr(EntityControlBlock* cb) : control_block_(cb) {
    if (control_block_ != nullptr) {
        control_block_->increment_strong();
    }
}

// 析构：释放强引用，必要时销毁实体和控制块
entity_Sptr::~entity_Sptr() {
    reset();
}

// 2. 赋值运算符实现
// 移动赋值
entity_Sptr& entity_Sptr::operator=(entity_Sptr&& other) noexcept {
    if (this != &other) {
        reset(); // 先释放当前控制块
        control_block_ = other.control_block_;
        other.control_block_ = nullptr; // 关键：置空原指针
    }
    return *this;
}

// entity_Sptr.cpp 中修改 reset()
void entity_Sptr::reset(VaEntity* entity) {
    EntityControlBlock* cb = control_block_;
    control_block_ = nullptr;
    
    if (cb != nullptr) {
        // 步骤1：强引用计数减1，用返回值判断是否归零（无竞态）
        bool strong_zero = cb->decrement_strong();
        // 强引用归零必须调用 destroy_entity()，确保实体先销毁
        if (strong_zero) {
            cb->destroy_entity(); // 正常流程销毁实体，避免兜底逻辑
        }

        // 步骤2：弱引用计数减1，销毁控制块（此时实体已安全销毁）
        bool weak_zero = cb->decrement_weak();
        if (weak_zero) {
            delete cb; // 控制块析构时，entity_ 已为 nullptr，无警告
        }
    }

    // 绑定新实体（原逻辑不变）
    if (entity != nullptr) {
        control_block_ = new EntityControlBlock(entity);
    }
}


// 3. 访问操作实现
VaEntity& entity_Sptr::operator*() const {
    VaEntity* entity = get();
    if (entity == nullptr) {
        throw std::runtime_error("Dereferencing null entity_Sptr");
    }
    return *entity;
}

VaEntity* entity_Sptr::operator->() const {
    VaEntity* entity = get();
    if (entity == nullptr) {
        throw std::runtime_error("Accessing member of null entity_Sptr");
    }
    return entity;
}

VaEntity* entity_Sptr::get() const {
    return control_block_ != nullptr ? control_block_->get_entity() : nullptr;
}

entity_Sptr::operator bool() const {
    return get() != nullptr;
}

// 4. 状态查询实现
size_t entity_Sptr::use_count() const {
    return control_block_ != nullptr ? control_block_->strong_count() : 0;
}

void entity_Sptr::swap(entity_Sptr& other) noexcept {
    std::swap(control_block_, other.control_block_);
}

// 5. 池化 release 方法（暂时空实现，后续完善）
void entity_Sptr::release() {
    // 后续补充
}

// 辅助函数：交换
void swap(entity_Sptr& a, entity_Sptr& b) noexcept {
    a.swap(b);
}

// 比较运算符
bool operator==(const entity_Sptr& a, const entity_Sptr& b) {
    return a.get() == b.get();
}

bool operator!=(const entity_Sptr& a, const entity_Sptr& b) {
    return a.get() != b.get();
}

}  // namespace va

#include "core/entity_Wptr.hpp"
#include "core/entity_Sptr.hpp"
#include <stdexcept>

namespace va {
// 1. 构造函数实现
entity_Wptr::entity_Wptr() noexcept : control_block_(nullptr) {}

// 从强指针构造：弱引用 +1
entity_Wptr::entity_Wptr(const entity_Sptr& strong) : control_block_(strong.control_block_) {
    if (control_block_ != nullptr) {
        control_block_->increment_weak();
    }
}

// 拷贝构造：弱引用 +1
entity_Wptr::entity_Wptr(const entity_Wptr& other) : control_block_(other.control_block_) {
    if (control_block_ != nullptr) {
        control_block_->increment_weak();
    }
}

// 移动构造：窃取所有权
entity_Wptr::entity_Wptr(entity_Wptr&& other) noexcept : control_block_(other.control_block_) {
    other.control_block_ = nullptr;
}

// 内部构造：从控制块构造
entity_Wptr::entity_Wptr(EntityControlBlock* cb) : control_block_(cb) {
    if (control_block_ != nullptr) {
        control_block_->increment_weak();
    }
}

// 析构：释放弱引用，必要时销毁控制块
entity_Wptr::~entity_Wptr() {
    reset();
}

// 2. 赋值运算符实现
entity_Wptr& entity_Wptr::operator=(const entity_Sptr& strong) {
    EntityControlBlock* new_cb = strong.control_block_;
    // 先加新控制块的弱引用
    if (new_cb != nullptr) {
        new_cb->increment_weak();
    }
    // 释放旧控制块
    reset();
    control_block_ = new_cb;
    return *this;
}

entity_Wptr& entity_Wptr::operator=(const entity_Wptr& other) {
    if (this != &other) {
        EntityControlBlock* new_cb = other.control_block_;
        if (new_cb != nullptr) {
            new_cb->increment_weak();
        }
        reset();
        control_block_ = new_cb;
    }
    return *this;
}

entity_Wptr& entity_Wptr::operator=(entity_Wptr&& other) noexcept {
    if (this != &other) {
        reset();
        control_block_ = other.control_block_;
        other.control_block_ = nullptr;
    }
    return *this;
}

// 重置弱指针
void entity_Wptr::reset() noexcept {
    EntityControlBlock* cb = control_block_;
    control_block_ = nullptr;

    if (cb != nullptr) {
        // 弱引用 -1，若归零且强引用已归零，则销毁控制块
        bool weak_zero = cb->decrement_weak();
        if (weak_zero && cb->strong_count() == 0) {
            delete cb;
        }
    }
}

// 3. 核心功能实现
// lock()：实体存活则返回强指针，否则返回空指针
entity_Sptr entity_Wptr::lock() const {
    if (expired()) {
        return entity_Sptr();  // 返回空强指针
    }
    // 调用强指针的内部构造（控制块已确保存活）
    return entity_Sptr(control_block_);
}

// 检查实体是否已销毁（强引用归零）
bool entity_Wptr::expired() const {
    return control_block_ == nullptr || !control_block_->is_alive();
}

// 获取弱引用计数
size_t entity_Wptr::use_count() const {
    return control_block_ != nullptr ? control_block_->weak_count() : 0;
}

void entity_Wptr::swap(entity_Wptr& other) noexcept {
    std::swap(control_block_, other.control_block_);
}

// 4. 重载 ->：等效于 lock()->（线程安全，过期抛异常）
entity_Sptr entity_Wptr::operator->() const {
    entity_Sptr sptr = lock();
    if (!sptr) {
        throw std::runtime_error("Accessing expired entity_Wptr");
    }
    return sptr;
}

// 辅助函数：交换
void swap(entity_Wptr& a, entity_Wptr& b) noexcept {
    a.swap(b);
}

// 比较运算符：比较指向的实体是否相同
bool operator==(const entity_Wptr& a, const entity_Wptr& b) {
    return a.lock().get() == b.lock().get();
}

bool operator!=(const entity_Wptr& a, const entity_Wptr& b) {
    return a.lock().get() != b.lock().get();
}
}  // namespace va

#include "core/VaEntity.hpp"
#include "core/VaEventUpstream.hpp"

#include <iostream>

namespace va
{

// Subsribe and Unsubscribe
void VaEntity::subscribe( std::shared_ptr< VaEventUpstream > upstream , std::vector< size_t > event_ids )
{
    if ( !upstream )
        return;
    for ( auto id : event_ids )
    {
        upstream->Register( id, Sptr_from_this() );
    }
}

void VaEntity::unsubscribe( std::shared_ptr< VaEventUpstream > upstream , std::vector< size_t > event_ids )
{
    if ( !upstream )
        return;
    for ( auto id : event_ids )
    {
        upstream->UnRegister( Sptr_from_this(), id );
    }
}

void VaEntity::unsubscribe( std::shared_ptr< VaEventUpstream > upstream )
{
    if ( !upstream )
        return;
    upstream->UnRegister( Sptr_from_this() );
}

// Push an event into the entity's buffer and handle it
void VaEntity::eventPush( std::shared_ptr< event::EventBase > event )
{
    std::lock_guard< std::mutex > lock( mtx );
    this->EventBuffer.push( event );
}

int VaEntity::processOneEvent()
{
    auto one_event = std::shared_ptr< event::EventBase >( nullptr );
    {
        std::lock_guard< std::mutex > lock( mtx );
        if( this->EventBuffer.empty() )return -1;
        one_event = this->EventBuffer.front();
        this->EventBuffer.pop();
        if ( one_event.get() == nullptr )
            return 0;
    }
    // handleEvent is a virtual function , need usr to implement it
    this->handleEvent( one_event );
    return 1;
}

// VaEntity.cpp 中修改 Raii()
void VaEntity::Raii() {
    std::lock_guard< std::mutex > lock( this->upstream_entity_mtx );

    // 1. 注销所有上游订阅（捕获 Sptr_from_this() 异常）
    for ( auto& upstream : Upstreams ) {
        if ( upstream ) {
            try {
                upstream->UnRegister( Sptr_from_this() );
            } catch (const std::exception& e) {
                std::cerr << "[WARNING] Failed to unregister upstream: " << e.what() << std::endl;
            }
        }
    }
    Upstreams.clear(); // 确保清空

    // 2. 递归清理子实体（捕获子实体 Raii() 异常）
    for ( auto& entity : downEntitys ) {
        if ( entity ) {
            try {
                entity->Raii();
            } catch (const std::exception& e) {
                std::cerr << "[WARNING] Failed to clean downEntity: " << e.what() << std::endl;
            }
        }
    }
    downEntitys.clear(); // 确保清空
}

};  // namespace va
// VaEventRouter.cpp
#include "core/VaEventRouter.hpp"

namespace va
{

bool VaEventRouter::Push( std::shared_ptr< event::EventBase > event )
{
    if ( !event ) return false;

    {
        std::lock_guard< std::mutex > lock( mtx );
        EventBuffer.push( event );
    }
    // Notify waiting thread about new event
    cv.notify_one();
    return true;
}
void VaEventRouter::DispatchOnce()
{
    std::shared_ptr< event::EventBase > event;
    size_t                              event_id  = 0;
    bool                                has_event = false;
    // pop an event
    {
        std::lock_guard< std::mutex > lock( mtx );
        if ( EventBuffer.empty() )
            return;
        event    = EventBuffer.front();
        event_id = event->id();
        EventBuffer.pop();
        has_event = true;
    }
    if ( !has_event || !event )
        return;

    // check if there is a co vector , refer it
    std::vector< entity_Wptr >* listeners_ptr = nullptr;
    {
        std::lock_guard< std::mutex > lock( mtx );
        if ( event_id < Listeners.size() && !Listeners[ event_id ].empty() )
        {
            listeners_ptr = &Listeners[ event_id ];
        }
    }
    if ( !listeners_ptr )
        return;

    // dispatch
    std::vector< entity_Wptr >& listeners = *listeners_ptr;
    for ( auto it = listeners.begin(); it != listeners.end(); )
    {
        auto sptr = it->lock();
        if ( sptr )
        {
            sptr->eventPush( event );
            ++it;
        }
        else
        {
            // delete the ptr if its object has been removed
            it = listeners.erase( it );
        }
    }
}

void VaEventRouter::thr_DispatchLoop() {
    std::unique_lock<std::mutex> lk(cv_mtx);
    while (running) {
        cv.wait(lk, [this] { 
        return !EventBuffer.empty() || !running.load(); 
         });
        if (!running) break;
        DispatchOnce();
    }

    while (!EventBuffer.empty()) {
        EventBuffer.pop();
    }
}
}  // namespace va
// VaEventUpstream
#include "core/VaEventUpstream.hpp"
#include "core/entity_Wptr.hpp"
#include <algorithm>
#include <thread>

namespace va
{

void VaEventUpstream::Register( size_t event_id, entity_Sptr entity )
{
    if ( !entity )
        return;

    std::lock_guard< std::mutex > lock( mtx );

    // Resize listener vector if necessary
    if ( event_id >= Listeners.size() )
    {
        Listeners.resize( event_id + 10 );
    }

    // Avoid re-registration
    auto& vec = Listeners[ event_id ];
    auto  found =
      std::find_if( vec.begin(), vec.end(), [ &entity ]( const entity_Wptr wptr ) {
          auto sptr = wptr.lock();
          return sptr && sptr == entity;
      } );
    // not found
    if ( found == vec.end() )
    {
        vec.push_back( entity );
        Listeners2[ entity ].push_back( event_id );
    }
}

void VaEventUpstream::UnRegister( entity_Sptr entity )
{
    if ( !entity )
        return;

    std::lock_guard< std::mutex > lock( mtx );
    auto                          it = Listeners2.find( entity );

    if ( it != Listeners2.end() )
    {
        for ( size_t idx : it->second )
        {
            if ( idx < Listeners.size() )
            {
                auto& vec = Listeners[ idx ];
                vec.erase( std::remove_if( vec.begin(), vec.end(),
                                           [ &entity ]( const entity_Wptr& wptr ) {
                                               auto sptr = wptr.lock();
                                               return sptr && sptr == entity;
                                           } ),
                           vec.end() );
            }
        }
        Listeners2.erase( it );
    }
}

void VaEventUpstream::UnRegister( size_t event_id )
{
    std::lock_guard< std::mutex > lock( mtx );

    if ( event_id < Listeners.size() )
    {
        auto& vec = Listeners[ event_id ];

        // Update Listeners2 for all entities in this event
        for ( auto& wptr : vec )
        {
            auto sptr = wptr.lock();
            if ( sptr )
            {
                auto it = Listeners2.find( sptr );
                if ( it != Listeners2.end() )
                {
                    auto& idxs = it->second;
                    idxs.erase( std::remove( idxs.begin(), idxs.end(), event_id ), idxs.end() );

                    if ( idxs.empty() )
                    {
                        Listeners2.erase( it );
                    }
                }
            }
        }

        vec.clear();
    }
}

void VaEventUpstream::UnRegister( entity_Sptr entity, size_t event_id )
{
    if ( !entity || event_id >= Listeners.size() )
        return;

    std::lock_guard< std::mutex > lock( mtx );

    // Remove from Listeners
    auto& vec = Listeners[ event_id ];
    vec.erase( std::remove_if( vec.begin(), vec.end(),
                               [ &entity ]( const entity_Wptr& wptr ) {
                                   auto sptr = wptr.lock();
                                   return sptr && sptr == entity;
                               } ),
               vec.end() );

    // Update Listeners2
    auto it = Listeners2.find( entity );
    if ( it != Listeners2.end() )
    {
        auto& idxs = it->second;
        idxs.erase( std::remove( idxs.begin(), idxs.end(), event_id ), idxs.end() );

        if ( idxs.empty() )
        {
            Listeners2.erase( it );
        }
    }
}

void VaEventUpstream::eventloopStart()
{
    if ( running )
        return;
    running     = true;
    eventThread = std::thread( &VaEventUpstream::thr_DispatchLoop, this );
}

void VaEventUpstream::eventloopStop()
{
    if ( !running )
        return;

    running = false;
    cv.notify_all();  // Wake up the waiting thread

    if ( eventThread.joinable() )
    {
        eventThread.join();
    }
}

}  // namespace va
#include "../../inc/core/VaEvent.hpp"
#include <iostream>
#include <string>
using std::cout;
VA_EVENT_DEFINE( ShitEvent )
int         x;
int         y;
int         size;
std::string name;
VA_EVENT_DEFINE_END

VA_EVENT_DEFINE( ShiEvent )
int         x;
int         y;
int         size;
std::string name;
VA_EVENT_DEFINE_END

void handleEvent( const va::event::EventBase& e )
{
    if ( va::event::is_event< ShitEvent >( e ) )
        {
            auto& shit = static_cast< const ShitEvent& >( e );
            cout << "你在坐标 x:" << shit.x << " y:" << shit.y
                 << " 的位置拉了一坨屎,大小为:" << shit.size << " 你给他取名叫做:" << shit.name
                 << "\n";
        }
}

int main()
{
    ShitEvent a_pile_of_shit, ww;
    ShiEvent  a_pile_of_shi, wwi;
    a_pile_of_shit.x    = 103;
    a_pile_of_shit.y    = 214;
    a_pile_of_shit.size = 100;
    a_pile_of_shit.name = "brother";

    va::event::EventBase& one = a_pile_of_shit;
    handleEvent( one );
    cout << a_pile_of_shit.id() << "\n";
    cout << ww.id() << "\n";
    cout << wwi.id() << "\n";
    cout << a_pile_of_shi.id() << "\n";
    cout << event_type_id< ShiEvent >() << "\n";
    return 0;
}
#include "../../inc/core/VaEventRouter.hpp"
#include <iostream>

va::VaEventRouter va_event_loop;

// Define a custom event type
VA_EVENT_DEFINE( MyEvent )
int value;
VA_EVENT_DEFINE_END

// Entity A: prints the event value
class EntityA : public va::VaEntity
{
protected:
    void handleEvent( std::shared_ptr< va::event::EventBase > event ) override
    {
        if ( va::event::is_event< MyEvent >( *event ) )
            {
                auto* myEvt = va::event::getIf< MyEvent >( *event );
                if ( myEvt )
                    {
                        std::cout << "[EntityA] Received MyEvent with value: " << myEvt->value
                                  << std::endl;
                    }
            }
    }
};

// Entity B: prints double the event value
class EntityB : public va::VaEntity
{
protected:
    void handleEvent( std::shared_ptr< va::event::EventBase > event ) override
    {
        if ( va::event::is_event< MyEvent >( *event ) )
            {
                auto* myEvt = va::event::getIf< MyEvent >( *event );
                if ( myEvt )
                    {
                        std::cout << "[EntityB] Received MyEvent, double value: "
                                  << ( myEvt->value * 2 ) << std::endl;
                    }
            }
    }
};

// Entity C: prints the event value squared
class EntityC : public va::VaEntity
{
protected:
    void handleEvent( std::shared_ptr< va::event::EventBase > event ) override
    {
        if ( va::event::is_event< MyEvent >( *event ) )
            {
                auto* myEvt = va::event::getIf< MyEvent >( *event );
                if ( myEvt )
                    {
                        std::cout << "[EntityC] Received MyEvent, squared value: "
                                  << ( myEvt->value * myEvt->value ) << std::endl;
                    }
            }
    }
};

int main()
{
    // Create entities
    auto a = va::make_entity_sptr< EntityA >();
    auto b = va::make_entity_sptr< EntityB >();
    auto c = va::make_entity_sptr< EntityB >();

    // Register entities to listen for MyEvent
    va_event_loop.Register( event_type_id< MyEvent >(), a );
    va_event_loop.Register( event_type_id< MyEvent >(), b );
    va_event_loop.Register( event_type_id< MyEvent >(), c );

    // Create and push an event
    auto evt   = std::make_shared< MyEvent >();
    evt->value = 42;
    va_event_loop.Push( evt );

    // Dispatch the event (each entity will handle it in its own way)
    // Create and push an event
    auto evt2   = std::make_shared< MyEvent >();
    evt2->value = 38;
    va_event_loop.Push( evt2 );

    // Dispatch the event (each entity will handle it in its own way)
    va_event_loop.DispatchOnce();
    va_event_loop.DispatchOnce();

    a->processOneEvent();
    b->processOneEvent();
    c->processOneEvent();
    a->processOneEvent();
    b->processOneEvent();
    c->processOneEvent();
    return 0;
}
#include "../../inc/core/VaEventRouter.hpp"
#include <cstdio>
#include <iostream>
#include <cstdlib>

// ANSI color codes
#define RESET   "\033[0m"
#define RED     "\033[31m"
#define GREEN   "\033[32m"
#define YELLOW  "\033[33m"
#define BLUE    "\033[34m"
#define MAGENTA "\033[35m"
#define CYAN    "\033[36m"
#define WHITE   "\033[37m"

auto eventrouter = new va::VaEventRouter();

// it should be in line 110 + , but I need it be called by `EntityDemo`
void stop_loop();

// Event types definition
VA_EVENT_DEFINE(event_1)
    std::string label = "null";
    void func_printid(){std::cout<< "A: "<< this->id() << std::endl;};
    event_1( std::string name ){label = name;};
VA_EVENT_DEFINE_END

VA_EVENT_DEFINE(event_2)
    std::string label = "null";
    void func_printid(){std::cout<< "B: "<< this->id() << std::endl;};
    event_2( std::string name ){label = name;};
VA_EVENT_DEFINE_END

VA_EVENT_DEFINE(event_3)
    std::string label = "null";
    void func_printid(){std::cout<< "C: "<< this->id() << std::endl;};
    event_3( std::string name ){label = name;};
VA_EVENT_DEFINE_END

VA_EVENT_DEFINE(event_4)
    std::string label = "null";
    void func_printid(){std::cout<< "D: "<< this->id() << std::endl;};
    event_4( std::string name ){label = name;};
VA_EVENT_DEFINE_END

VA_EVENT_DEFINE(event_5)
    std::string label = "null";
    void func_printid(){std::cout<< "E: "<< this->id() << std::endl;};
    event_5( std::string name ){label = name;};
VA_EVENT_DEFINE_END

// Entities types  definition

class EntityDemo : public va::VaEntity
{
    public:
        std::string analyzeEventLabel ( std::shared_ptr< va::event::EventBase > _event )
        {
            std::string one;
            if( _event->id() == event_type_id< event_1 >()) one = va::event::getIf<event_1>(*_event.get())->label;
            else if( _event->id() == event_type_id< event_2 >()) one = va::event::getIf<event_2>(*_event.get())->label;
            else if( _event->id() == event_type_id< event_3 >()) one = va::event::getIf<event_3>(*_event.get())->label;
            else if( _event->id() == event_type_id< event_4 >()) one = va::event::getIf<event_4>(*_event.get())->label;
            else if( _event->id() == event_type_id< event_5 >()) one = va::event::getIf<event_5>(*_event.get())->label;
            else {
                std::cerr<< RED << "Error: bad event type in EntityDemo::analyzeEventLabel()" << RESET << std::endl;
                stop_loop();
                exit(EXIT_FAILURE);
            }
            return one;
        };
};

class EntityA : public EntityDemo 
{
    protected:
        void handleEvent(std::shared_ptr< va::event::EventBase > event)
        {
            std::cout << CYAN << "Entity type A" << RESET << "\n"
                <<"Instance pointer: "<<(unsigned long )this
                <<"\nReceived event with type ID: "
                <<  event->id() 
                <<"\nAnd ins label: "<<analyzeEventLabel(event)<<std::endl;
        };
};

class EntityB : public EntityDemo 
{
    protected:
        void handleEvent(std::shared_ptr< va::event::EventBase > event)
        {
            std::cout << CYAN << "Entity type B" << RESET << "\n"
                <<"Instance pointer: "<<(unsigned long )this
                <<"\nReceived event with type ID: "
                <<  event->id()
                <<"\nAnd ins label: "<<analyzeEventLabel(event)<<std::endl;
        };
};

class EntityC : public  EntityDemo 
{
    protected:
        void handleEvent(std::shared_ptr< va::event::EventBase > event)
        {
            std::cout << CYAN << "Entity type C" << RESET << "\n"
                <<"Instance pointer: "<<(unsigned long )this
                <<"\nReceived event with type ID: "
                <<  event->id() 
                <<"\nAnd ins label: "<<analyzeEventLabel(event)<<std::endl;
        };
};

std::unordered_map< std::string , std::shared_ptr<va::event::EventBase> > EventContainer;
std::unordered_map< std::string , va::entity_Sptr > EntityContainer;

void make_event ( std::string name , char type );
void make_entity( std::string name , char   type );
void bond( std::string nameevent , std::string nameentity);
void unbond( std::string nameevent , std::string nameentity);
void list_con( std::string name );
void start_loop();
void go_process();


int main(int argc , char** argv)
{

    while( true )
    {
        std::string cmd, arg1, arg2, arg3;
        
        // Prompt for command input
        std::cout << BLUE << ">> " << RESET;
        std::cin >> cmd;

        if ( cmd == "make" )
        {
            std::cout << YELLOW << "Enter type (event/entity): " << RESET;
            std::cin >> arg1;
            
            if (arg1 == "event") 
            {
                std::cout << YELLOW << "Enter event type (A-E): " << RESET;
                std::cin >> arg2;
                
                std::cout << YELLOW << "Enter event name: " << RESET;
                std::cin >> arg3;
                
                if (arg2.size() == 1) {
                    make_event(arg3, arg2[0]);
                } else {
                    std::cout << RED << "Invalid event type format!" << RESET << std::endl;
                }
            }
            else if (arg1 == "entity") 
            {
                std::cout << YELLOW << "Enter entity type (A-C): " << RESET;
                std::cin >> arg2;
                
                std::cout << YELLOW << "Enter entity name: " << RESET;
                std::cin >> arg3;
                
                if (arg2.size() == 1) {
                    make_entity(arg3, arg2[0]);
                } else {
                    std::cout << RED << "Invalid entity type format!" << RESET << std::endl;
                }
            }
            else {
                std::cout << RED << "Invalid make subcommand!" << RESET << std::endl;
            }
        }
        else if ( cmd == "bond" )
        {
            std::cout << YELLOW << "Enter event type (A-E): " << RESET;
            std::cin >> arg1;
            
            std::cout << YELLOW << "Enter entity name: " << RESET;
            std::cin >> arg2;
            
            bond(arg1, arg2);
        }
        else if ( cmd == "unbond" )
        {
            std::cout << YELLOW << "Enter event type (A-E): " << RESET;
            std::cin >> arg1;
            
            std::cout << YELLOW << "Enter entity name: " << RESET;
            std::cin >> arg2;
            
            unbond(arg1, arg2);
        }
        else if ( cmd == "list" )
        {
            std::cout << YELLOW << "Enter container to list (event/entity): " << RESET;
            std::cin >> arg1;
            
            list_con(arg1);
        }
        else if ( cmd == "shot" )
        {
            std::cout << YELLOW << "Enter event name to trigger: " << RESET;
            std::cin >> arg1;

            auto it = EventContainer.find(arg1);
            if (it != EventContainer.end()) {
                eventrouter->Push(it->second);
                EventContainer.erase( arg1 );
                std::cout << GREEN << "Event '" << arg1 << "' triggered!" << RESET << std::endl;
            } else {
                std::cout << RED << "Event '" << arg1 << "' not found!" << RESET << std::endl;
            }
        }
        else if ( cmd == "start")
        {
            start_loop();
        }
        else if ( cmd == "stop" )
        {
            stop_loop();
        }
        else if ( cmd == "exit")
        { 
            stop_loop();
            break;
        }
        else if ( cmd == "clear")
        { 
            system("clear");
        }
        else if ( cmd == "help" )
        {
            std::cout << MAGENTA <<
                "Available commands:\n"<<
                "make   - Create event or entity\n"<<
                "bond   - Bind event to entity\n"<<
                "unbond - Unbind event from entity\n"<<
                "list   - List contents of container\n"<<
                "shot   - Trigger specified event\n"<<
                "start  - Start event loop\n"<<
                "stop   - Stop event loop\n"<<
                "exit   - Exit program\n"<<
                "clear  - Clear screen\n"<<
                "help   - Show this help message\n"<<
                "go     - Tell to process all event\n"<< //TODO
                "ls     - Show available types\n"<< RESET << std::endl;
        }
        else if ( cmd == "ls")
        { 
            std::cout << MAGENTA <<
                "Event types:  A,B,C,D,E \n"<<
                "Entity types: A,B,C\n" << RESET;
        }
        else if ( cmd == "go")
        {
            std::cout<<YELLOW<<" Event process go!"<<RESET<<std::endl;
            go_process();
        }
        else 
        {
            std::cout << RED << "Unknown command! Enter help for available commands" << RESET << std::endl;
        }

    }

    delete eventrouter;
    return EXIT_SUCCESS;
}

void make_event ( std::string name , char type )
{
    if (EventContainer.find(name) != EventContainer.end()) {
        std::cout << RED << "Event '" << name << "' already exists!" << RESET << std::endl;
        return;
    }

    std::shared_ptr<va::event::EventBase> temp_event;
    switch (type) {
        case 'A': temp_event = std::make_shared<event_1>(name); break;
        case 'B': temp_event = std::make_shared<event_2>(name); break;
        case 'C': temp_event = std::make_shared<event_3>(name); break;
        case 'D': temp_event = std::make_shared<event_4>(name); break;
        case 'E': temp_event = std::make_shared<event_5>(name); break;
        default: std::cout << RED << "Invalid event type! Must be A-E" << RESET << std::endl; return;
    }    
    EventContainer.insert({name, temp_event});
    std::cout << GREEN << "Created event '" << name << "' (type " << type << ")" << RESET << std::endl;
}

void make_entity( std::string name , char type )
{
    if (EntityContainer.find(name) != EntityContainer.end()) {
        std::cout << RED << "Entity '" << name << "' already exists!" << RESET << std::endl;
        return;
    }

    va::entity_Sptr temp_entity;
    switch (type) {
        case 'A': temp_entity = va::make_entity_sptr<EntityA>(); break;
        case 'B': temp_entity = va::make_entity_sptr<EntityB>(); break;
        case 'C': temp_entity = va::make_entity_sptr<EntityC>(); break;
        default: std::cout << RED << "Invalid entity type! Must be A-C" << RESET << std::endl; return;
    }
    temp_entity->setLabel(name);
    EntityContainer.insert({name, temp_entity});
    std::cout << GREEN << "Created entity '" << name << "' (type " << type << ")" << RESET << std::endl;
}

void bond( std::string event_type , std::string nameentity)
{
    size_t event_id;
    switch (event_type[0]) {
        case 'A': event_id = event_type_id<event_1>(); break;
        case 'B': event_id = event_type_id<event_2>(); break;
        case 'C': event_id = event_type_id<event_3>(); break;
        case 'D': event_id = event_type_id<event_4>(); break;
        case 'E': event_id = event_type_id<event_5>(); break;
        default: std::cout << RED << "Bond failed: Invalid event type!" << RESET << std::endl; return;
    }

    auto ent_it = EntityContainer.find(nameentity);
    if (ent_it == EntityContainer.end()) {
        std::cout << RED << "Bond failed: Entity '" << nameentity << "' not found!" << RESET << std::endl;
        return;
    }

    eventrouter->Register(event_id, ent_it->second);
    std::cout << GREEN << "Bonded event type " << event_type << " to entity '" << nameentity << "'" << RESET << std::endl;
}

void unbond( std::string event_type , std::string nameentity)
{
    size_t event_id;
    switch (event_type[0]) {
        case 'A': event_id = event_type_id<event_1>(); break;
        case 'B': event_id = event_type_id<event_2>(); break;
        case 'C': event_id = event_type_id<event_3>(); break;
        case 'D': event_id = event_type_id<event_4>(); break;
        case 'E': event_id = event_type_id<event_5>(); break;
        default: std::cout << RED << "Unbond failed: Invalid event type!" << RESET << std::endl; return;
    }

    auto ent_it = EntityContainer.find(nameentity);
    if (ent_it == EntityContainer.end()) {
        std::cout << RED << "Unbond failed: Entity '" << nameentity << "' not found!" << RESET << std::endl;
        return;
    }

    eventrouter->UnRegister(ent_it->second, event_id);
    std::cout << GREEN << "Unbonded event type " << event_type << " from entity '" << nameentity << "'" << RESET << std::endl;
}

void list_con( std::string name )
{
    if (name == "event") {
        std::cout << WHITE << "Event Container (" << EventContainer.size() << " items):" << RESET << std::endl;
        for (const auto& pair : EventContainer) {
            std::cout << "  " << pair.first << std::endl;
        }
    }
    else if (name == "entity") {
        std::cout << WHITE << "Entity Container (" << EntityContainer.size() << " items):" << RESET << std::endl;
        for (const auto& pair : EntityContainer) {
            std::cout << "  " << pair.first << std::endl;
        }
    }
    else {
        std::cout << RED << "Unknown container! Use 'event' or 'entity'" << RESET << std::endl;
    }
}

void start_loop()
{
    if (eventrouter->IsRunning()) {
        std::cout << YELLOW << "Event loop is already running!" << RESET << std::endl;
    } else {
        eventrouter->eventloopStart();
        std::cout << GREEN << "Event loop started" << RESET << std::endl;
    }
}

void stop_loop()
{
    if (!eventrouter->IsRunning()) {
        std::cout << YELLOW << "Event loop is not running!" << RESET << std::endl;
    } else {
        eventrouter->eventloopStop();
        std::cout << GREEN << "Event loop stopped" << RESET << std::endl;
    }
}
    
void go_process()
{
    for(  auto itr_ent : EntityContainer )
    {
        while( true )
        {
            int fi = itr_ent.second->processOneEvent();
            if ( fi == -1 )break;
        }
    }
}
/*
 * (C) Lc3124 2024 
 * LICENSE (MIT)
 * 这个文件用来实现VaTui::Color类
 *
 */

#ifndef _VACOLOR_CPP_
#define _VACOLOR_CPP_

//Va
#include "VaTui.hpp"
// std
#include <cmath>
#include <cstdio>
#include <cstring>
#include <algorithm>
// sys
#include <unistd.h>

/*
 * 简单封装一些东西，没必要过多说明
 */

void VaTui::Color::fastOutput(const char *str) {
    write(STDOUT_FILENO, str, strlen(str));
}

const char* VaTui::Color::_SetColor4bit(int front, int background)
{
    static char escapeCommand[64];
    snprintf(escapeCommand, sizeof(escapeCommand), "\033[%dm\033[%dm", front, background);
    return escapeCommand;
}

void VaTui::Color::SetColor4bit(int front, int background)
{
    //我不清楚静态成员怎么显式调用其他成员，都知道这个函数是VaTui::Color的就好,后面同理
    fastOutput(_SetColor4bit(front, background));
}

const char* VaTui::Color::_SetColor256(int front, int background)
{ 
    static char escapecommand[64];
    snprintf(escapecommand, sizeof(escapecommand),"\033[38;5;%dm\033[48;5;%dm",front,background);
    return escapecommand;
}

void VaTui::Color::SetColor256(int front, int background)
{
    fastOutput(_SetColor256(front, background));
}

const char* VaTui::Color:: _set_background_color_RGB(int R,int B,int G)
{
    static char escapecommand[64];
    snprintf(escapecommand, sizeof(escapecommand),"\033[48;2;%d,%d,%dm",R,G,B);
    return escapecommand;
}

void VaTui::Color::set_background_color_RGB(int R, int B,int G)
{
    fastOutput(_set_background_color_RGB(R, B, G));
}

const char* VaTui::Color::_set_front_color_RGB(int R,int B,int G)
{
    static char escapecommand[64];
    snprintf(escapecommand, sizeof(escapecommand),"\033[38;2;%d,%d,%dm",R,G,B);
    return escapecommand;
}

void VaTui::Color::set_front_color_RGB(int R, int B,int G)
{
    fastOutput(_set_front_color_RGB(R, G, B));
}

const char* VaTui::Color::_SetEffect(short effect,bool isEnable)
{
    static char escapecommand[64];
    if (isEnable == true){
        snprintf(escapecommand,sizeof(escapecommand),"\033[%dm",effect);
    }
    else {
        snprintf(escapecommand,sizeof(escapecommand),"\033[2%dm",effect);
    }

    return escapecommand;
}

void VaTui::Color::SetEffect(short effect,bool isEnable)
{
    fastOutput(_SetEffect(effect, isEnable));
}

void VaTui::Color::ColorEffectReset()
{
    fastOutput(_ColorEffectReset());
}

const char* VaTui::Color::_ColorEffectReset()
{
    static char escapecommand[64];
    snprintf(escapecommand,sizeof(escapecommand),"\033[0m");
    return escapecommand;
}


/*
* 将给定的 RGB 颜色值（r、g、b，范围通常是0 - 255）转换为对应的 ANSI 256 色模式下的颜色代码,
* 我无法保证在实际使用中的效果，后续会进行测试验证。
* 首先计算颜色的灰度值，然后根据颜色是否为灰度（即 r、g、b 相等）以及灰度值范围，
* 然后来确定对应的 ANSI 256 色代码，返回该代码值。
*
* PS:
* 有几个函数不是我自己写的，所以不确定他们可不可以正常工作
* 但我会测试它们的
*/


/*
 * 预期范围内似乎没有问题，但是没有检查输入
 */
int VaTui::Color::RgbToAnsi256Color( int r,int g,int b )
{
    int gray = 0.299 * r + 0.587 * g + 0.114 * b;
    if (r == g && g == b) {
        if (gray < 8) return 16;
        if (gray > 248) return 231;
        return std::round((gray - 8) / 247.0 * 24) + 232;
    } else {
        int ansiR = std::round((double)r / 51.0);
        int ansiG = std::round((double)g / 51.0);
        int ansiB = std::round((double)b / 51.0);
        return 16 + (ansiR * 36) + (ansiG * 6) + ansiB;
    }
}

/*这个函数不是我写的，我也不知道这玩意能不能正常工作，我会测试它的*/
//将Ansi的256色转换成RGB颜色的三个分量( r , g , b ) 
void VaTui::Color::Ansi256ColorToRGB(int ansi256Color, int& r, int& g, int& b)
{
    if (ansi256Color >= 0 && ansi256Color <= 15) {
        // 处理前16个基本颜色（0 - 15），对应特定的固定RGB值
        switch (ansi256Color) {
            case 0:  // 黑色
                r = 0;
                g = 0;
                b = 0;
                break;
            case 1:  // 红色
                r = 170;
                g = 0;
                b = 0;
                break;
            case 2:  // 绿色
                r = 0;
                g = 170;
                b = 0;
                break;
            case 3:  // 黄色
                r = 170;
                g = 170;
                b = 0;
                break;
            case 4:  // 蓝色
                r = 0;
                g = 0;
                b = 170;
                break;
            case 5:  // 紫色
                r = 170;
                g = 0;
                b = 170;
                break;
            case 6:  // 深绿色（青色）
                r = 0;
                g = 170;
                b = 170;
                break;
            case 7:  // 白色
                r = 170;
                g = 170;
                b = 170;
                break;
            case 8:  // 亮黑色（灰色）
                r = 85;
                g = 85;
                b = 85;
                break;
            case 9:  // 亮红色
                r = 255;
                g = 85;
                b = 85;
                break;
            case 10:  // 亮绿色
                r = 85;
                g = 255;
                b = 85;
                break;
            case 11:  // 亮黄色
                r = 255;
                g = 255;
                b = 85;
                break;
            case 12:  // 亮蓝色
                r = 85;
                g = 85;
                b = 255;
                break;
            case 13:  // 亮紫色
                r = 255;
                g = 85;
                b = 255;
                break;
            case 14:  // 亮深绿色（亮青色）
                r = 85;
                g = 255;
                b = 255;
                break;
            case 15:  // 亮白色
                r = 255;
                g = 255;
                b = 255;
                break;
        }
    } else if (ansi256Color >= 16 && ansi256Color <= 231) {
        // 处理 16 - 231 的颜色，通过特定算法从颜色代码计算RGB分量
        int index = ansi256Color - 16;
        r = (index / 36) * 51;
        index %= 36;
        g = (index / 6) * 51;
        b = (index % 6) * 51;
    } else if (ansi256Color >= 232 && ansi256Color <= 255) {
        // 处理 232 - 255 的灰度颜色，根据代码计算灰度对应的RGB值
        int gray = 8 + (ansi256Color - 232) * 10;
        r = gray;
        g = gray;
        b = gray;
    }
} 

//混合两个Ansi256色，返回混合的结果
int VaTui::Color::MixAnsi256Colors( int color1,int color2 )
{
    int r1, g1, b1, r2, g2, b2;
    if (color1 >= 16 && color1 <= 231) {
        int index = color1 - 16;
        r1 = index / 36;
        index %= 36;
        g1 = index / 6;
        b1 = index % 6;
        r1 *= 51;
        g1 *= 51;
        b1 *= 51;
    } else if (color1 >= 232 && color1 <= 255) {
        int gray = ((color1 - 232) * 247 / 24) + 8;
        r1 = g1 = b1 = gray;
    }

    if (color2 >= 16 && color2 <= 231) {
        int index = color2 - 16;
        r2 = index / 36;
        index %= 36;
        g2 = index / 6;
        b2 = index % 6;
        r2 *= 51;
        g2 *= 51;
        b2 *= 51;
    } else if (color2 >= 232 && color2 <= 255) {
        int gray = ((color2 - 232) * 247 / 24) + 8;
        r2 = g2 = b2 = gray;
    }

    int r = (r1 + r2) / 2;
    int g = (g1 + g2) / 2;
    int b = (b1 + b2) / 2;

    return RgbToAnsi256Color(r, g, b);
}

//将Ansi256色色号反色处理，返回反色结果
int VaTui::Color::AntiAnsi256Color(int colorcode)
{
    int color1 =colorcode;
    int r1, g1, b1;
    if (color1 >= 16 && color1 <= 231) {
        int index = color1 - 16;
        r1 = index / 36;
        index %= 36;
        g1 = index / 6;
        b1 = index % 6;
        r1 *= 51;
        g1 *= 51;
        b1 *= 51;
    } else if (color1 >= 232 && color1 <= 255) {
        int gray = ((color1 - 232) * 247 / 24) + 8;
        r1 = g1 = b1 = gray;
    }
    int r = 250 - r1;
    int g = 250 - g1;
    int b = 250 - b1;

    return RgbToAnsi256Color(r, g, b);
}

/*
 * 下面这一段不是我写的，是deepseek生成的代码，
 * 我会测试他们的
 */
// 将 ANSI 16 色转换为 ANSI 256 色的函数
int VaTui::Color::Ansi16ColorToAnsi256(int ansi16Color)
{
    if (ansi16Color >= 0 && ansi16Color <= 7) {
        return ansi16Color + 16;  // 前8个基本颜色对应到 256 色中的前16个颜色里，索引偏移16
    } else if (ansi16Color >= 8 && ansi16Color <= 15) {
        return ansi16Color + 232 - 8;  // 后8个亮色对应到 256 色中的特定范围，进行相应索引转换
    }
    return 0;  // 如果传入的 16 色代码不符合规范，返回默认值（这里返回0，可根据实际情况调整）
}

// 将 ANSI 256 色转换为 ANSI 16 色的函数
int VaTui::Color::Ansi256ColorToAnsi16(int ansi256Color)
{
    if (ansi256Color >= 16 && ansi256Color <= 231) {
        // 256 色中的前 216 种颜色转换到 16 色中的前 8 种基本色的逻辑
        int index = ansi256Color - 16;
        int r = index / 36;
        index %= 36;
        int g = index / 6;
        int b = index % 6;
        if (r == g && g == b) {
            return r;
        }
        return 8;  // 如果不是单一颜色，对应到 16 色中的亮黑色（这里简单对应，可根据需求调整更合适的逻辑）
    } else if (ansi256Color >= 232 && ansi256Color <= 255) {
        // 256 色中的灰度范围颜色对应到 16 色中的后 8 种亮色的逻辑
        return (ansi256Color - 232 + 8);
    }
    return 0;  // 如果传入的 256 色代码不符合规范，返回默认值（这里返回0，可根据实际情况调整）
}


int VaTui::Color::Ansi256ColorToAnsi4bit(int ansi256Color, bool isFrontOrBack) {
    if (ansi256Color < 16) {
        // 如果已经是4bit颜色，直接返回
        return ansi256Color;
    }

    if (ansi256Color >= 232) {
        // 处理灰度颜色
        int gray = ansi256Color - 232;
        if (gray < 4) return isFrontOrBack ? 30 : 40; // 黑色
        if (gray < 8) return isFrontOrBack ? 90 : 100; // 亮黑色
        if (gray < 12) return isFrontOrBack ? 37 : 47; // 白色
        return isFrontOrBack ? 97 : 107; // 亮白色
    }

    // 处理彩色
    int colorIndex = ansi256Color - 16;
    int r = (colorIndex / 36) % 6;
    int g = (colorIndex / 6) % 6;
    int b = colorIndex % 6;

    // 将6级颜色映射到4级颜色
    r = r < 3 ? 0 : 1;
    g = g < 3 ? 0 : 1;
    b = b < 3 ? 0 : 1;

    int ansi4bitColor = (r << 2) | (g << 1) | b;

    // 映射到4bit颜色
    static const int ansi4bitMap[] = {
        0, 4, 2, 6, 1, 5, 3, 7
    };

    int result = ansi4bitMap[ansi4bitColor];

    // 如果是前景色，返回前景色代码，否则返回背景色代码
    return isFrontOrBack ? result + 30 : result + 40;
}

int VaTui::Color::Ansi4bitColorToAnsi16(int ansi4bitColor) {
    // 4bit颜色直接映射到16色
    if (ansi4bitColor < 8) {
        return ansi4bitColor;
    } else {
        return ansi4bitColor + 8;
    }
}
#endif 

/*
 * (c) 2024 Lc3124 
 * License (MIT)
 *
 * 本代码片段主要实现了与终端光标操作相关的一系列功能，
 * 包括将光标移动到指定位置、按指定方向和距离移动光标、
 * 重置光标到默认位置、隐藏和显示光标等操作，
 * 旨在方便在终端应用开发中对光标进行灵活控制，以实现更丰富的用户界面交互效果。
 */

#ifndef _VACUSOR_CPP_
#define _VACUSOR_CPP_

//Va
#include "VaTuiEnums.hpp"
#include "VaTui.hpp"
// std
#include <cstdio>
#include <cstring>
// sys
#include <unistd.h>


void VaTui::Cursor::fastOutput(const char *str) {
    write(STDOUT_FILENO, str, strlen(str));
}
const char* VaTui::Cursor::_CursorMoveTo(int h, int w)
{
    static char escapeCommand[64];
    snprintf(escapeCommand, sizeof(escapeCommand), "\033[%d;%dH", h, w);
    return escapeCommand;
}
void VaTui::Cursor::CursorMoveTo(int h, int w)
{
    fastOutput(_CursorMoveTo(h, w));
}
const char* VaTui::Cursor::_CursorMove(int dr, int ds)
{
    static char escapeCommand[64];
    switch (dr)
    {
        case CUR_LEFT:
            {
                // 生成向左移动指定距离（ds）的 ANSI 转义序列字符串，格式为 "\033[%dD"，其中 %d 会被实际移动距离替换。
                snprintf(escapeCommand, sizeof(escapeCommand), "\033[%dD", ds);
                return escapeCommand;
            }
        case CUR_RIGHT:
            {
                // 生成向右移动指定距离（ds）的 ANSI 转义序列字符串，格式为 "\033[%dC"。
                snprintf(escapeCommand, sizeof(escapeCommand), "\033[%dC", ds);
                return escapeCommand;
            }
        case CUR_UP:
            {
                // 生成向上移动指定距离（ds）的 ANSI 转义序列字符串，格式为 "\033[%dA"。
                snprintf(escapeCommand, sizeof(escapeCommand), "\033[%dA", ds);
                return escapeCommand;
            }
        case CUR_DOWN:
            {
                // 生成向下移动指定距离（ds）的 ANSI 转义序列字符串，格式为 "\033[%dB"。
                snprintf(escapeCommand, sizeof(escapeCommand), "\033[%dB", ds);
                return escapeCommand;
            }
        default:
            // 如果传入的移动方向枚举值不合法（不在预定义的方向枚举范围内），则返回 nullptr，表示无法生成有效的移动转义序列。
            return nullptr;
    }
}
void VaTui::Cursor::CursorMove(int dr, int ds)
{
    fastOutput(_CursorMove(dr, ds));
}

const char*VaTui::Cursor:: _CursorReset()
{
    return "\033[H";
}
void VaTui::Cursor::CursorReset()
{
    fastOutput("\033[H");
}

const char* VaTui::Cursor::_CursorHide()
{
    return "\033[?25l";
}
// 通过调用 fastOutput 函数输出由 _CursorHide 提供的 ANSI 转义序列，从而在终端上实际隐藏光标。
void VaTui::Cursor::CursorHide()
{
    fastOutput("\033[?25l");
}

// Show the cursor.
// 返回用于显示光标的 ANSI 转义序列字符串，其固定为 "\033[?25h"，直接返回此字符串指针，供后续输出操作来实现显示光标功能，可在之前隐藏光标的场景结束后，重新显示光标以便正常交互操作。
const char* VaTui::Cursor::_CursorShow()
{
    return "\033[?25h";
}
// 通过调用 fastOutput 函数输出由 _CursorShow 提供的 ANSI 转义序列，从而在终端上实际显示光标。
void VaTui::Cursor::CursorShow()
{
    fastOutput("\033[?25h");
}

#endif
/*
 * (c) 2025 Lc3124 
 * License (MIT)
 * VaTui::System的实现 
 */

#ifndef _VASYSTEM_CPP_
#define _VASYSTEM_CPP_

//Va
#include "VaTui.hpp"
//std
#include <iostream>
#include <ctime>
#include <cstdlib>
//unix
#include <unistd.h>
#include <sys/utsname.h>
#include <pwd.h>

std::string VaTui::System::getUserName() {
    uid_t uid = getuid();
    struct passwd *pw = getpwuid(uid);
    if (pw!= nullptr) {
        return std::string(pw->pw_name);
    }
    return "";

}

// 获取当前时间
std::string VaTui::System::getCurrentTime() {
    time_t now = time(nullptr);
    char buffer[80];
    struct tm *timeinfo = localtime(&now);
    strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", timeinfo);
    return std::string(buffer);

}

//获取环境变量
std::string VaTui::System::getRunningEnvironment(const char *index) {
    const char *env = std::getenv(index);
    std::string result = "";
    if (env!= nullptr) {
        result += env;
    }
    return result;

}

// 获取设备名称（这里通过utsname结构体获取系统信息中的机器名部分来近似表示设备名称）
std::string VaTui::System::getDeviceName() {
    struct utsname uts;
    if (uname(&uts)!= -1) {
        return std::string(uts.machine);
    }
    return "";

}

// 获取主机名
std::string VaTui::System::getHostName() {
    char hostname[256];
    if (gethostname(hostname, sizeof(hostname))!= -1) {
        return std::string(hostname);
    }
    return "";
}

// 获取运行目录
std::string VaTui::System::getRunningDirectory() {
    char buffer[256];
    if (getcwd(buffer, sizeof(buffer))!= nullptr) {
        return std::string(buffer);
    }
    return "";

}

std::string VaTui::System::getSystemOuput(const char * cmd) {
    FILE* pipe = popen(cmd, "r");
    if (!pipe) {
        std::cerr << "popen failed!" << std::endl;
        return "";
    }

    char buffer[128];
    std::string result = "";
    while (!feof(pipe)) {
        if (fgets(buffer, 128, pipe)!= nullptr) {
            result += buffer;
        }
    }

    pclose(pipe);

    return result;
}
#endif
#include "VaTui.hpp"

// std
#include <cstdio>
#include <cstring>
#include <iostream>
#include <stdexcept>
// sys
#include <fcntl.h>
#include <sys/ioctl.h>
#include <termios.h>
#include <unistd.h>

// 全局变量，保存原始终端属性和当前终端属性
termios originalAttrs;
termios currentAttrs;

// 辅助函数，用于安全地设置终端属性，添加异常处理机制
void
    VaTui::Term::setTerminalAttrsSafely ( const termios &newAttrs )
{
    if ( tcsetattr ( STDIN_FILENO, TCSANOW, &newAttrs ) != 0 )
        {
            throw std::runtime_error ( "Failed to set terminal attributes." );
        }
    currentAttrs = newAttrs;
}

// 辅助函数，用于安全地获取终端属性，添加异常处理机制
void
    VaTui::Term::getTerminalAttrsSafely ()
{
    if ( tcgetattr ( STDIN_FILENO, &currentAttrs ) != 0 )
        {
            throw std::runtime_error ( "Failed to get terminal attributes." );
        }
}

// 保存终端原始设置
void
    VaTui::Term::SaveTerm ()
{
    getTerminalAttrsSafely ();
    originalAttrs = currentAttrs;
}

// 恢复终端原始设置
void
    VaTui::Term::RestoreTerm ()
{
    setTerminalAttrsSafely ( originalAttrs );
    // system("reset");
}

// 清空整个屏幕
const char *
    VaTui::Term::_Clear ()
{
    return "\033[2J";
}
void
    VaTui::Term::Clear ()
{
    fastOutput ( "\033[2J" );
}

// 清空从光标位置到行尾的区域
const char *
    VaTui::Term::_ClearLine ()
{
    return "\033[K";
}
void
    VaTui::Term::ClearLine ()
{
    fastOutput ( "\033[K" );
}

// 获取终端属性
void
    VaTui::Term::getTerminalAttributes ()
{
    getTerminalAttrsSafely ();
}

// 设置终端属性
void
    VaTui::Term::setTerminalAttributes ( const termios &newAttrs )
{
    setTerminalAttrsSafely ( newAttrs );
}

// 启用终端回显
void
    VaTui::Term::enableEcho ()
{
    termios newAttrs = currentAttrs;
    newAttrs.c_lflag |= ECHO;
    setTerminalAttrsSafely ( newAttrs );
}

// 禁用终端回显
void
    VaTui::Term::disableEcho ()
{
    termios newAttrs = currentAttrs;
    newAttrs.c_lflag &= ~ECHO;
    setTerminalAttrsSafely ( newAttrs );
}

// 启用控制台缓冲
void
    VaTui::Term::enableConsoleBuffering ()
{
    int flags = fcntl ( STDIN_FILENO, F_GETFL );
    fcntl ( STDIN_FILENO, F_SETFL, flags & ~O_SYNC );
}

// 禁用控制台缓冲
void
    VaTui::Term::disableConsoleBuffering ()
{
    int flags = fcntl ( STDIN_FILENO, F_GETFL );
    fcntl ( STDIN_FILENO, F_SETFL, flags | O_SYNC );
}

// 获取终端大小
void
    VaTui::Term::getTerminalSize ( int &rows, int &cols )
{
    struct winsize w;
    if ( ioctl ( STDOUT_FILENO, TIOCGWINSZ, &w ) == 0 )
        {
            rows = w.ws_row;
            cols = w.ws_col;
        }
    else
        {
            throw std::runtime_error ( "Failed to get terminal size." );
        }
}

// 设置光标位置
void
    VaTui::Term::setCursorPosition ( int row, int col )
{
    std::cout << "\033[" << row << ";" << col << "H";
    std::cout.flush (); // 手动刷新输出缓冲区，确保光标位置及时更新显示
}

// 保存光标位置
void
    VaTui::Term::saveCursorPosition ()
{
    std::cout << "\033[s";
    std::cout.flush (); // 刷新输出缓冲区，保证保存操作生效
}

// 恢复光标位置
void
    VaTui::Term::restoreCursorPosition ()
{
    std::cout << "\033[u";
    std::cout.flush (); // 刷新输出缓冲区，保证恢复操作生效
}

// 快速输出内容到终端
void
    VaTui::Term::fastOutput ( const char *str )
{
    write ( STDOUT_FILENO, str, strlen ( str ) );
}

// 非缓冲获取按键，改进以避免影响标准输出刷新
char
    VaTui::Term::nonBufferedGetKey ()
{
    char           buf = 0;
    struct termios old = { 0 };
    if ( tcgetattr ( 0, &old ) < 0 ) perror ( "tcgetattr()" );
    old.c_lflag &= ~ICANON; // 非规范模式
    old.c_cc[ VMIN ]  = 1;  // 最少读取一个字符
    old.c_cc[ VTIME ] = 0;  // 无超时
    if ( tcsetattr ( 0, TCSANOW, &old ) < 0 ) perror ( "tcsetattr()" );
    if ( read ( 0, &buf, 1 ) < 0 ) perror ( "read" );
    // 恢复原始终端属性
    if ( tcsetattr ( 0, TCSANOW, &old ) < 0 ) perror ( "tcsetattr()" );
    return (int) buf;
}

// 获取终端类型
const char *
    VaTui::Term::getTerminalType ()
{
    return std::getenv ( "TERM" );
}

// 设置行缓冲模式
void
    VaTui::Term::setLineBuffering ( bool enable )
{
    termios newAttrs = currentAttrs;
    if ( enable )
        {
            newAttrs.c_lflag |= ICANON;
        }
    else
        {
            newAttrs.c_lflag &= ~ICANON;
        }
    setTerminalAttrsSafely ( newAttrs );
}

// 获取一个字符，类似getch，改进以确保回显正确处理
char
    VaTui::Term::getCharacter ()
{
    disableEcho ();
    char c = nonBufferedGetKey ();
    enableEcho ();
    return c;
}

// 判断终端是否支持某一功能
bool
    VaTui::Term::isTerminalFeatureSupported ( const char *feature )
{
    const char *termType = getTerminalType ();
    if ( termType == nullptr )
        {
            return false;
        }
    return ( strstr ( termType, feature ) != nullptr );
}

// 设置字符输入延迟
void
    VaTui::Term::setCharacterDelay ( int milliseconds )
{
    termios newAttrs       = currentAttrs;
    newAttrs.c_cc[ VMIN ]  = 0;
    newAttrs.c_cc[ VTIME ] = milliseconds / 100;
    setTerminalAttrsSafely ( newAttrs );
}

// 获取输入速度
int
    VaTui::Term::getInputSpeed ()
{
    getTerminalAttrsSafely ();
    return cfgetospeed ( &currentAttrs );
}

// 设置输入速度
void
    VaTui::Term::setInputSpeed ( int speed )
{
    termios newAttrs = currentAttrs;
    cfsetospeed ( &newAttrs, static_cast<speed_t> ( speed ) );
    cfsetispeed ( &newAttrs, static_cast<speed_t> ( speed ) );
    setTerminalAttrsSafely ( newAttrs );
}

// 设置输出速度
void
    VaTui::Term::setOutputSpeed ( int speed )
{
    termios newAttrs = currentAttrs;
    cfsetospeed ( &newAttrs, static_cast<speed_t> ( speed ) );
    setTerminalAttrsSafely ( newAttrs );
}

// 检测是否有按键按下
int
    VaTui::Term::getkeyPressed ( char &k )
{
    struct termios oldt, newt;
    int            oldf;
    getTerminalAttrsSafely ();
    oldt = currentAttrs;
    newt = oldt;
    newt.c_lflag &= ~( ICANON | ECHO );
    oldf = fcntl ( STDIN_FILENO, F_GETFL );
    fcntl ( STDIN_FILENO, F_SETFL, oldf | O_NONBLOCK );
    setTerminalAttrsSafely ( newt );

    char c;
    int  res = read ( STDIN_FILENO, &c, 1 );
    if ( res > 0 )
        {
            k = c;
            setTerminalAttrsSafely ( oldt );
            fcntl ( STDIN_FILENO, F_SETFL, oldf );
            return 1;
        }
    else
        {
            setTerminalAttrsSafely ( oldt );
            fcntl ( STDIN_FILENO, F_SETFL, oldf );
            k = static_cast<char> ( -1 );
            return -1;
        }
}

// 设置光标形状
void
    VaTui::Term::setCursorShape ( CursorShape shape )
{
    termios newAttrs = currentAttrs;
    switch ( shape )
        {
        case CURSOR_BLOCK:
            newAttrs.c_cflag &= ~( ECHOCTL );
            break;
        case CURSOR_UNDERLINE:
            newAttrs.c_cflag |= ( ECHOCTL | ECHOE );
            break;
        case CURSOR_VERTICAL_BAR:
            newAttrs.c_cflag |= ECHOCTL;
            break;
        }
    setTerminalAttrsSafely ( newAttrs );
}

#include <iostream>
void
    VaTui::Term::FlushStdOut ()
{
    std::cout << fflush ( stdout );
}
/*
 * (c) 2025 Lc3124
 * License (MIT)
 * VaTui::Utf的实现
 */

#ifndef _VAUTF_CPP_
#define _VAUTF_CPP_

#include "VaTui.hpp"


//get the width of a UTF character 
size_t VaTui::Utf::getUtf8CharWidth(const char* s) {
    if (!s ||!*s) return 0;
    unsigned char c = static_cast<unsigned char>(*s);
    if (c < 0x80) return 1;
    else if ((c & 0xE0) == 0xC0) return 2;
    else if ((c & 0xF0) == 0xE0) return 3;
    else if ((c & 0xF8) == 0xF0) return 4;
    else return 0;

}

// recognize a ASCII character 
bool VaTui::Utf::isAscii(char c) {
    return (c & 0x80) == 0;

}

// 判断是否为 UTF-8 多字节序列的开头字节
bool VaTui::Utf::isUtf8StartByte(char c) {
    // 将 char 类型转换为 unsigned char 类型，避免符号位影响按位与操作
    unsigned char uc = static_cast<unsigned char>(c);
    // UTF-8 多字节序列的后续字节以 10 开头，所以只要不是以 10 开头就是开头字节
    return (uc & 0xC0) != 0x80;
}


// 判断是否为 UTF-8 编码字符
bool VaTui::Utf::isUtf8Char(const char* bytes, int len) {
    if (len <= 0) return false;
    char firstByte = bytes[0];
    if (isAscii(firstByte)) return true;
    if (isUtf8StartByte(firstByte)) {
        int numBytes;
        if ((firstByte & 0xE0) == 0xC0) numBytes = 2;
        else if ((firstByte & 0xF0) == 0xE0) numBytes = 3;
        else if ((firstByte & 0xF8) == 0xF0) numBytes = 4;
        else return false;
        return len == numBytes;

    }
    return false;

}

// 判断是否为 GBK 编码字符  
bool VaTui::Utf::isGbkChar(const char* bytes, int len) {
    if (len!= 2) return false;
    unsigned char firstByte = static_cast<unsigned char>(bytes[0]);
    unsigned char secondByte = static_cast<unsigned char>(bytes[1]);
    return ((firstByte >= 0x81 && firstByte <= 0xFE) && (secondByte >= 0x40 && secondByte <= 0xFE && secondByte!= 0x7F));

}

int VaTui::Utf::getUtf8ByteCount(char c) {
    unsigned char uc = static_cast<unsigned char>(c);
    if ((uc & 0x80) == 0) {
        // 单字节字符 (0xxxxxxx)
        return 1;
    } else if ((uc & 0xE0) == 0xC0) {
        // 双字节字符 (110xxxxx)
        return 2;
    } else if ((uc & 0xF0) == 0xE0) {
        // 三字节字符 (1110xxxx)
        return 3;
    } else if ((uc & 0xF8) == 0xF0) {
        // 四字节字符 (11110xxx)
        return 4;
    }
    // 无效的 UTF-8 起始字节
    return -1; 
}

// 懒得写注释了，这段代码没有问题
bool VaTui::Utf::getUtf8CharaInString( std::string resource , std::string &save , int index )
{
    save = "";
    int i = 0;
    // NOTICE! 这里utf_cnt 从-1开始，但实际上index是从0开始索引的，这是个魔法数字 
    int utf_cnt = -1; 
    while (i < resource.size())
    {
        if (VaTui::Utf::isUtf8StartByte(resource[i]))
        {
            utf_cnt++;
            if (utf_cnt == index)
            {
                int byteCount = VaTui::Utf::getUtf8ByteCount(resource[i]);
                if (i + byteCount > resource.size()) {
                    return false;
                }
                for (int j = 0; j < byteCount; j++)
                {
                    save.push_back(resource[i + j]);
                }
                return true;
            }
            i += VaTui::Utf::getUtf8ByteCount(resource[i]);
        }
        else
        {
            i++;
        }
    }
    return false;
}

int VaTui::Utf::getUtf8StringLen( std::string resource )
{
    int i=0 , cnt=0 ;
    while( resource.size() != i )
    {
        if(VaTui::Utf::isUtf8StartByte(resource.at(i)))
        {
            cnt ++ ;
        }
        i++;
    }
    return cnt;
}


#endif
#ifndef _VATUIENUMS_HPP_

#define _VATUIENUMS_HPP_

// VaCursor类中光标移动的枚举常量
enum CursorMovement{
    CUR_LEFT  = 0,
    CUR_RIGHT = 1,
    CUR_UP    = 2,
    CUR_DOWN  = 3,
};

// 用于定义光标形状的枚举
enum CursorShape {
    CURSOR_BLOCK = 0,
    CURSOR_UNDERLINE = 1,
    CURSOR_VERTICAL_BAR = 2
};

// 4位颜色模式下的前景色和背景色枚举定义
namespace color4bit {
    enum color_4bit {
        FRONT_BLACK = 30,
        FRONT_RED = 31,
        FRONT_GREEN = 32,
        FRONT_YELLOW = 33,
        FRONT_BLUE = 34,
        FRONT_PURPLE = 35,
        FRONT_DEEP_GREEN = 36,
        FRONT_WHITE = 37,
        BACKGROUND_BLACK = 40,
        BACKGROUND_RED = 41,
        BACKGROUND_GREEN = 42,
        BACKGROUND_YELLOW = 43,
        BACKGROUND_BLUE = 44,
        BACKGROUND_PURPLE = 45,
        BACKGROUND_DEEP_GREEN = 46,
        BACKGROUND_WHITE = 47
    };
}

// 16位颜色模式下的颜色枚举定义
enum color16 {
    BLACK = 0,
    RED = 1,
    GREEN = 2,
    YELLOW = 3,
    BLUE = 4,
    PURPLE = 5,
    DEEP_GREEN = 6,
    WHITE = 7,
    BRIGHT_BLACK = 8,
    BRIGHT_RED = 9,
    BRIGHT_GREEN = 10,
    BRIGHT_YELLOW = 11,
    BRIGHT_BLUE = 12,
    BRIGHT_PURPLE = 13,
    BRIGHT_DEEP_GREEN = 14,
    BRIGHT_WHITE = 15
};

// 定义各种文本显示效果的枚举类型
enum AnsiEffect {
    BOLD = 1,
    DIM = 2,
    ITALIC = 3,
    UNDERLINE = 4,
    BLINK_SLOW = 5,
    BLINK_FAST = 6,
    REVERSE = 7,
    CONCEAL = 8,
    DELETE = 9
};

#endif
/*
 * (c) 2024 Lc3124
 * License (MIT)
 *
 * 这个文件是VaTui的声明
 * VaTui包括5个子类，用于
 * 颜色操作，光标操作，终端控制，系统信息获取，utf字节识别和处理
 *
 * 可以看作是一个符号列表
 *
 */

/*
 * PS(29 Dec 24):
 * 我打算重新决定VaTui类的结构，于是现在现有的源代码都没法马上编译
 * Makefile也要重写
 * 于是我把win_src的分支删掉了
 *
 * 这个文件我将来会打上详细的英文注释
 *
 */

#ifndef _VATUI_FILE_H_
#define _VATUI_FILE_H_

#include "VaTuiEnums.hpp"
#include <string>

class VaTui
{
  public:
    class Color;
    class Cursor;
    class System;
    class Term;
    class Utf;
};

/*
 * VaColor class
 * VaColor 类是用于管理和操作终端文本颜色以及相关显示效果的核心类，
 * 它提供了一系列静态方法来方便地设置文本的颜色、效果等，
 * 并且包含了一些用于颜色转换、混合等实用功能的函数
 */
class VaTui::Color
{
  private:
    /*
     * `fastOutput`是一个私有的成员，
     * 用来实现快速输出文字到终端，
     * 实际上是对`系统调用write()向标准输出写数据`的封装
     */
    static inline void fastOutput ( const char *str );

  public:
    /*
     * 以下为颜色输出相关的函数
     * 使用Ansi转义序列的颜色控制字符实现
     * 对终端有一定要求，如果终端不支持这些Ansi序列
     * 或者对转义字符的解释不符合预期效果
     * 就会导致乱码等
     *
     * 以下方法按照返回值类型来分为2种
     * 例如
     *
     * _SetColor256:
     * 生成用于设置16位颜色模式下文本前景色和背景色的 ansi 转义序列字符串，
     * 返回该字符串指针。
     * 按照 ansi
     * 转义序列中针对16位颜色模式的特定格式，结合传入的前景色和背景色参数，
     * 使用 snprintf 函数构造相应字符串，
     * 存储在 escapecommand 数组中供后续输出到终端来改变颜色显示。
     *
     * _SetColor256(int front, int background):
     * 借助 fastoutput 函数输出 _setcolor256 生成的 ansi 转义序列，
     * 实现将终端文本的前景色和背景色设置为指定的16位颜色模式颜色。
     *
     * 使用样例见手册页
     */
    static const char *_SetColor4bit ( int front, int background );
    static void        SetColor4bit ( int front, int background );
    static const char *_SetColor256 ( int front, int background );
    static void        SetColor256 ( int front, int background );
    static const char *_set_background_color_RGB ( int R, int B, int G );
    static void        set_background_color_RGB ( int R, int B, int G );
    static const char *_set_front_color_RGB ( int R, int B, int G );
    static void        set_front_color_RGB ( int R, int B, int G );

    /*
     * 设置Ansi文字特效
     *
     * SetEffect:
     * 根据传入的文本显示效果枚举值（effect）以及是否启用该效果的布尔值（isEnable），
     * 生成对应的 ANSI 转义序列字符串，返回该字符串指针。
     * 如果 isEnable 为 true，则按照启用效果的 ANSI 转义序列格式，
     * 使用 snprintf 函数构造相应字符串；
     * 若为 false，则按照禁用效果的格式构造字符串，
     * 存储在 escapecommand 数组中供后续输出使用。
     *
     * 同理，SetEffect用来立即应用_SetEffect的构造结果
     */
    static const char *_SetEffect ( short effect, bool isEnable );
    static void        SetEffect ( short effect, bool isEnable );
    static const char *_ColorEffectReset ();
    static void        ColorEffectReset ();

    /*
     * 其它
     *
     * 以下是一些其他的实用颜色处理相关函数，
     * 包括颜色模式之间的转换、颜色混合以及颜色反转等功能，
     * 为更复杂的颜色操作需求提供支持，
     * 方便在不同颜色应用场景中进行灵活的颜色调整和处理。
     *
     * PS:(Lc3124)
     * 说实话，我也不清楚什么时候才会真正用到颜色混合相关的函数
     * 但其他的，比如颜色格式的转换完全可以用来兼容不同颜色支持的终端
     * 我相信它们有不错的效果
     */

    //这些函数名称和签名使其功能显而易见，所以不过多注释
    static int  RgbToAnsi256Color ( int r, int g, int b );
    static void Ansi256ColorToRGB ( int ansi256Color, int &r, int &g, int &b );
    static int  MixAnsi256Colors ( int color1, int color2 );
    static int  AntiAnsi256Color ( int colorcode );
    static int  Ansi16ColorToAnsi256 ( int ansi16Color );
    static int  Ansi256ColorToAnsi16 ( int ansi256Color );
    // 4bit颜色是有前景和背景之分的，这里根据isFrontOrBack来决定操作对象
    static int Ansi256ColorToAnsi4bit ( int ansi256Color, bool isFrontOrBack );
    //因为16色和256色兼容，所以只做4到16色转换
    //但是4bit颜色是有前景和背景之分的，这里转换后就没有这样的区分了
    static int Ansi4bitColorToAnsi16 ( int ansi4bitColor );
};

/*
 * Functions related to cursor actions.
 * VaCursor 类封装了一系列与终端光标操作相关的函数，通过生成和输出 ANSI
 * 转义序列来控制终端光标的位置、显示状态等，为在终端应用中实现自定义的光标行为提供了便捷的方式。
 */
class VaTui::Cursor
{
  private:
    //封装write,为特效字符串提供输出
    static inline void fastOutput ( const char *str );

  public:
    /*
     * Functions related to cursor actions.
     * 以下是与光标操作相关的一系列公共函数，提供了不同类型的光标操作功能，
     * 例如移动到指定位置、按方向移动以及控制光标显示隐藏等，
     * 方便开发者根据具体需求灵活操控终端光标。
     */

    /*
     * 以下程序用来控制光标移动
     * 通过构建Ansi转义序列的相关字符和参数来使终端控制光标移动
     * 但是需要终端的支持
     */
    static const char *_CursorMoveTo ( int h, int w );
    static void        CursorMoveTo ( int h, int w );

    //这个CursorMove方法用来移动光标，dr传入枚举常量参数,ds传入移动方向
    static const char *_CursorMove ( int dr, int ds );

    static void        CursorMove ( int dr, int ds );
    static const char *_CursorReset ();

    // 返回用于将光标重置到默认位置（通常是终端屏幕左上角，即第一行第一列）的
    // ANSI 转义序列字符串。
    static void        CursorReset ();
    static const char *_CursorHide ();

    static void        CursorHide ();
    static const char *_CursorShow ();
    static void        CursorShow ();
};

/*
 * 这个某块用来获取各种系统信息
 * 比如用户名，运行环境，所在目录等等
 */
class VaTui::System
{
  public:
    static std::string getUserName ();
    static std::string getCurrentTime ();

    //这个需要说明的是此函数用于获取环境变量，index为变量名，返回变量值
    static std::string getRunningEnvironment ( const char *index );

    static std::string getDeviceName ();
    static std::string getHostName ();
    static std::string getRunningDirectory ();
    static std::string getSystemOuput ( const char *cmd );
};

/*
 * 这个模块用于控制终端来实现输入输出和一些关键的操作
 * 包括了检测终端对某个功能的支持情况、非阻塞获取键盘输入、
 * 屏幕清空、光标位移、启用或禁用回显等等
 *
 * 在linux下的实现是对terminfo,termios等库的封装
 */
class VaTui::Term
{

  public:
    //这个函数会获取一次终端设置,保存在一个静态变量中
    static void getTerminalAttributes ();
    static void setTerminalAttributes ( const struct termios &newAttrs );
    static void setTerminalAttrsSafely ( const termios &newAttrs );
    static void getTerminalAttrsSafely ();

    //保存(刷新)终端设置
    static void SaveTerm ();
    //恢复终端设置
    static void RestoreTerm ();
    //生成用来清空屏幕的Ansi字符串
    static const char *_Clear ();
    //上一个函数的直接输出版本
    static void Clear ();
    //清除一行
    static const char *_ClearLine ();
    static void        ClearLine ();
    //启用回显
    static void enableEcho ();
    static void disableEcho ();
    //启用控制台缓冲
    static void enableConsoleBuffering ();
    static void disableConsoleBuffering ();
    //获取终端大小
    static void getTerminalSize ( int &rows, int &cols );
    //设置光标位置
    static void setCursorPosition ( int row, int col );
    static void saveCursorPosition ();
    static void restoreCursorPosition ();
    //无缓冲输出
    static void fastOutput ( const char *str );
    //类似getch()
    static char nonBufferedGetKey ();
    //返回终端类型
    static const char *getTerminalType ();
    //启、禁用行缓冲
    static void setLineBuffering ( bool enable );
    //类似getch()，但没有终端回显，副作用是执行完后会把回显打开
    static char getCharacter ();
    //检查feature是否支持
    static bool isTerminalFeatureSupported ( const char *feature );

    //关于什么速度设置，我不清楚，按照《Linux/Unix编程手册》实现的
    void        setCharacterDelay ( int milliseconds );
    static int  getInputSpeed ();
    static void setInputSpeed ( int speed );
    static void setOutputSpeed ( int speed );
    //无阻塞获取按键，失败就返回-1，否则不返回固定的值
    static int getkeyPressed ( char &k );
    //根据传入的枚举常量参数来设置光标形状
    static void setCursorShape ( CursorShape shape );
    //所有更改终端和fastOutput都有可能影响到标准输出,
    //如果你不是在开发一个完全的TUI程序
    //请使用这个函数刷新标准输出
    static void FlushStdOut ();
};

/*
 * 这个模块用来识别Utf字节，
 * 当然还有一些其他的功能，也会在之后加入新的功能
 */
class VaTui::Utf
{
  public:
    // 检测一段含有UTF字符的字符串的第一个有效字符的内存宽度
    // 详见手册
    size_t getUtf8CharWidth ( const char *s );
    // 根据一个 utf8字符的首位字节来确定该utf8字符的字节数
    static int  getUtf8ByteCount ( char c );
    static bool isAscii ( char c );
    // 判断一个字节是不是utf字符编码字符的开头字节
    static bool isUtf8StartByte ( char c );
    // 判断一个常规意义上的字符串是不是一个完整的utf8字符
    static bool isUtf8Char ( const char *bytes, int len );
    // 如方法名
    static bool isGbkChar ( const char *bytes, int len );
    // 从一段字符串中获取第index个Utf8字符,返回是否成功
    static bool getUtf8CharaInString ( std::string resource, std::string &save,
                                       int index );
    // 获取一个字符串的utf8字符数量
    static int getUtf8StringLen ( std::string resource );
    /* TODO */
    // 获取一个字符串在常规显示屏上的等宽字体tty上占用的宽度
    static int getStrWidthOs ( std::string resource );
};

#endif
#ifndef _ENABLE_ENTITY_SHARED_FROM_THIS_HPP_
#define _ENABLE_ENTITY_SHARED_FROM_THIS_HPP_

namespace va {
// 前向声明智能指针（无需包含头文件）
class entity_Sptr;
class entity_Wptr;

class enable_entity_shared_from_this {
protected:
    // 构造/析构：保护访问，仅子类可继承
    enable_entity_shared_from_this() noexcept;
    enable_entity_shared_from_this(const enable_entity_shared_from_this&) noexcept;
    enable_entity_shared_from_this& operator=(const enable_entity_shared_from_this&) noexcept;
    virtual ~enable_entity_shared_from_this() noexcept;  // 虚析构，确保子类正确销毁

public:
    // 核心方法：返回自身的强指针/弱指针
    entity_Sptr Sptr_from_this();
    entity_Wptr Wptr_from_this() const;

private:
    // 关键：用弱指针存储自身（指针类型，前向声明支持）
    entity_Wptr* weak_this_;

    // 友元：允许 entity_Sptr 初始化 weak_this_
    friend class entity_Sptr;
};
}  // namespace va

#endif  // _ENABLE_ENTITY_SHARED_FROM_THIS_HPP_

#ifndef _ENTITY_CONTROL_BLOCK_HPP_
#define _ENTITY_CONTROL_BLOCK_HPP_

#include <atomic>
#include <mutex>
#include <cassert>

namespace va {
// 前向声明：无需包含 VaEntity.hpp，避免依赖
class VaEntity;

class EntityControlBlock {
public:
    // 构造：接收 VaEntity 指针（仅指针，前向声明足够）
    explicit EntityControlBlock(VaEntity* entity);
    // 析构：不直接销毁实体（由强引用计数决定）
    ~EntityControlBlock();

    // 强引用计数操作
    void increment_strong();
    bool decrement_strong();  // 返回 true 表示强引用归零

    // 弱引用计数操作
    void increment_weak();
    bool decrement_weak();  // 返回 true 表示弱引用归零

    // 状态查询
    size_t strong_count() const;
    size_t weak_count() const;
    bool is_alive() const;  // 强引用 > 0 表示实体存活

    // 实体访问（线程安全）
    VaEntity* get_entity() const;
    // 销毁实体（仅强引用归零后调用）
    void destroy_entity();

private:
    VaEntity* entity_;                  // 管理的实体指针（前向声明支持）
    std::atomic_size_t strong_cnt_;     // 强引用计数（原子操作）
    std::atomic_size_t weak_cnt_;       // 弱引用计数（原子操作）
    mutable std::mutex mutex_;          // 保护实体指针访问（防止析构时访问）
};
}  // namespace va

#endif  // _ENTITY_CONTROL_BLOCK_HPP_

#ifndef _ENTITY_SPTR_HPP_
#define _ENTITY_SPTR_HPP_

#include <cstddef>
#include <functional>
#include "EntityControlBlock.hpp"  // 依赖控制块声明
#include "enable_entity_shared_from_this.hpp"

namespace va {
// 前向声明：弱指针后续实现，避免循环
class entity_Wptr;

class entity_Sptr {
public:
    // 1. 基础构造
    explicit entity_Sptr(VaEntity* entity = nullptr);  // 从原始指针构造
    entity_Sptr(const entity_Sptr& other);             // 拷贝构造
    entity_Sptr(entity_Sptr&& other) noexcept;         // 移动构造
    explicit entity_Sptr(const entity_Wptr& weak);     // 从弱指针构造（后续实现弱指针后完善）
    ~entity_Sptr();                                    // 析构

    // 2. 赋值运算符
    entity_Sptr& operator=(const entity_Sptr& other);
    entity_Sptr& operator=(entity_Sptr&& other) noexcept;
    void reset(VaEntity* entity = nullptr);  // 重置指针（放弃所有权）

    // 3. 访问操作
    VaEntity& operator*() const;             // 解引用
    VaEntity* operator->() const;            // 成员访问
    VaEntity* get() const;                   // 获取原始指针
    explicit operator bool() const;          // 空指针判断

    // 4. 状态查询
    size_t use_count() const;                // 获取强引用计数
    void swap(entity_Sptr& other) noexcept;  // 交换指针

    // 5. 池化相关（后续实现 EntityPool 后完善）
    void release();

private:
    EntityControlBlock* control_block_;  // 指向控制块（核心）

    // 友元：允许弱指针访问控制块，允许控制块构造强指针
    friend class entity_Wptr;
    explicit entity_Sptr(EntityControlBlock* cb);  // 内部构造（供弱指针 lock() 使用）
};

// 辅助函数：交换两个强指针
void swap(entity_Sptr& a, entity_Sptr& b) noexcept;

// 比较运算符：比较指向的实体是否相同
bool operator==(const entity_Sptr& a, const entity_Sptr& b);
bool operator!=(const entity_Sptr& a, const entity_Sptr& b);

// 模板函数：创建 entity_Sptr 管理的 VaEntity 子类对象
// T：VaEntity 子类类型（如 EntityA、MyEntity）
// Args：构造函数参数类型（可变参数）
template <typename T, typename... Args>
entity_Sptr make_entity_sptr(Args&&... args) {
    // 编译期检查：确保 T 是 VaEntity 的派生类，避免错误类型
    static_assert(std::is_base_of<VaEntity, T>::value, 
            "make_entity_sptr: T must inherit from va::VaEntity");

    // 1. 用完美转发传递参数，创建 T 类型对象（new 裸指针仅在此处出现，外部不可见）
    // 2. 直接传递给 entity_Sptr 构造函数，由智能指针接管所有权
    return entity_Sptr(new T(std::forward<Args>(args)...));
}
}  // namespace va

namespace std
{
    template <>
        struct hash<va::entity_Sptr> {
            // 哈希函数：基于实体地址计算哈希值
            size_t operator()(const va::entity_Sptr& sptr) const noexcept {
                // 1. 获取实体的原始指针（空指针返回 0）
                va::VaEntity* entity = sptr.get();
                if (entity == nullptr) {
                    return 0;  // 空指针的哈希值固定为 0
                }
                // 2. 将指针转换为 size_t（地址值），作为哈希值
                // （或用 std::hash<void*> 计算指针的哈希，更通用）
                return std::hash<void*>()(static_cast<void*>(entity));
            }
        };

};
#endif  // _ENTITY_SPTR_HPP_

#ifndef _ENTITY_WPTR_HPP_
#define _ENTITY_WPTR_HPP_

#include <cstddef>
#include "EntityControlBlock.hpp"

namespace va {
// 前向声明强指针
class entity_Sptr;

class entity_Wptr {
public:
    // 1. 基础构造
    entity_Wptr() noexcept;                      // 默认构造（空指针）
    entity_Wptr(const entity_Sptr& strong);      // 从强指针构造（核心）
    entity_Wptr(const entity_Wptr& other);       // 拷贝构造
    entity_Wptr(entity_Wptr&& other) noexcept;   // 移动构造
    ~entity_Wptr();                              // 析构

    // 2. 赋值运算符
    entity_Wptr& operator=(const entity_Sptr& strong);
    entity_Wptr& operator=(const entity_Wptr& other);
    entity_Wptr& operator=(entity_Wptr&& other) noexcept;
    void reset() noexcept;  // 重置弱指针

    // 3. 核心功能
    entity_Sptr lock() const;  // 获取强指针（实体存活则返回有效指针）
    bool expired() const;       // 检查实体是否已销毁
    size_t use_count() const;   // 获取弱引用计数
    void swap(entity_Wptr& other) noexcept;  // 交换

    // 4. 便捷访问：重载 ->，等效于 lock()->
    entity_Sptr operator->() const;

private:
    EntityControlBlock* control_block_;  // 指向控制块（与强指针共享）

    // 友元：允许强指针访问控制块
    friend class entity_Sptr;
    explicit entity_Wptr(EntityControlBlock* cb);  // 内部构造
};

// 辅助函数：交换两个弱指针
void swap(entity_Wptr& a, entity_Wptr& b) noexcept;

// 比较运算符
bool operator==(const entity_Wptr& a, const entity_Wptr& b);
bool operator!=(const entity_Wptr& a, const entity_Wptr& b);
}  // namespace va

#endif  // _ENTITY_WPTR_HPP_

#ifndef _VA_ENTITY_HPP_
#define _VA_ENTITY_HPP_

#include "VaEvent.hpp"
#include "entity_Sptr.hpp"
#include "enable_entity_shared_from_this.hpp"
#include <memory>
#include <mutex>
#include <queue>
#include <string>
#include <vector>

namespace va
{

// Pre-declare VaEventUpstream
class VaEventUpstream;

/*
 * The base class for all event-receiving entities in the event system.
 *
 * VaEntity provides a thread-safe event buffer and a virtual interface for handling events.
 * Users should inherit from VaEntity and implement handleEvent() to define custom event logic.
 *
 * Typical usage:
 *
 * class MyEntity : public va::VaEntity {
 * protected:
 *     // Implement your own event handling logic here!
 *     void handleEvent(std::shared_ptr<event::EventBase> event) override {
 *         if (va::event::is_event<MyEvent>(*event)) {
 *             auto* myEvt = va::event::getIf<MyEvent>(*event);
 *             if (myEvt) {
 *                 // Do something with myEvt
 *             }
 *         }
 *     }
 * };
 *
 * MyEntity entity;
 * entity.eventPush(myEventPtr); // Pushes and immediately handles the event
 * entity.processOneEvent();     // Optionally, process one event from the buffer
 */
class VaEntity :  public enable_entity_shared_from_this
{
  protected:
    // TODO need a lock-free queue
    std::mutex mtx , upstream_entity_mtx;  ///< Mutex for thread-safe access to the event buffer

    // Store all events received by this entity (FIFO queue)
    std::queue< std::shared_ptr< event::EventBase > > EventBuffer;

    // Store indexes of upstreams and downEntitys, they are used to mark
    // where the Entity subscribes events from and what sub-Entities it contains.
    std::vector< std::shared_ptr< VaEventUpstream > > Upstreams;
    std::vector< entity_Sptr > downEntitys;
    
    /*
     * Handle a single event.
     * Users should override this method in derived classes to implement custom event handling
     * logic. This function is called by eventPush() and processOneEvent().
     *
     * event: The event to handle.
     */
    virtual void handleEvent( std::shared_ptr< event::EventBase > event ) = 0;

    /*
     * String label , used to check it while running
     */
    std::string label;

    /**/

  public:

    /*
     * Safely subscribe to an upstream event source.
     * This function registers the entity with the specified VaEventUpstream to receive events.
     * You must use this mothod to subscribe to events instead of using one in `VaUpstream`
     */
    void subscribe( std::shared_ptr< VaEventUpstream > upstream , std::vector< size_t > event_ids );
    /*
     * Safely unsubscribe from an upstream event source.
     * This function unregisters the entity from the specified VaEventUpstream, stopping it from
     * receiving further events.
     */
    void unsubscribe( std::shared_ptr< VaEventUpstream > upstream , std::vector< size_t > event_ids );
    void unsubscribe( std::shared_ptr< VaEventUpstream > upstream );
    
    /*
     * Push an event into the buffer and 'handlevent' method will handle it.
     * This function is thread-safe. The event is pushed into the buffer and handleEvent() is
     * called.
     *
     * event: The event to push.
     */
    virtual void eventPush( std::shared_ptr< event::EventBase > event );

    /*
     * Process one event from the buffer (FIFO).
     * If the buffer is not empty, pops and handles the front event.
     * Useful for asynchronous or deferred event processing.
     *  
     *  return:
     *      1: sucess  ( callback-function has been finished )
     *      0: bad event
     *     -1: empty buffer
     */
    virtual int processOneEvent();

    /* 
     * List of Data Interface
     */
    std::string getLabel();
    void        setLabel( std::string nameLabel ){this->label = nameLabel;};

    /*
     * Destructor, used to clean up the event registration and 
     * clean other resources.
     */
    void Raii();
    virtual ~VaEntity()
    {
      Raii();
    };
};

};  // namespace va

#endif
/*
 * VaEvent.hpp
 *
 * This header provides a set of utilities and macros for defining and working with custom event
 * types in a type-safe and extensible way. It is designed for use in event-driven systems, such as
 * GUI frameworks or game engines.
 *
 * Features:
 * - Unique type IDs for each event type at runtime.
 * - Macros to simplify event type definition.
 * - Type-safe utilities for event type checking and casting.
 *
 * Example usage:
 *
 * VA_EVENT_DEFINE(MouseEvent)
 *     int x, y;
 *     bool isClick;
 * VA_EVENT_DEFINE_END
 *
 * MouseEvent oneevent{100, 100, 1};
 *
 * void handleEvent(const EventBase& e)
 * {
 *     if (is_event<MouseEvent>(e))
 *     {
 *         auto& mouse = static_cast<const MouseEvent&>(e);
 *         std::cout << mouse.x << mouse.y;
 *     }
 * }
 *
 * Main components:
 * - event_type_id<T>(): Returns a unique ID for each event type.
 * - EVENT_BASE_METHOD(T): Implements the required id() method for the event.
 * - VA_EVENT_DEFINE / VA_EVENT_DEFINE_END: Macros to define new event types.
 * - is_event<T>(const EventBase&): Checks if an event is of type T.
 * - getIf<T>(const EventBase&): Returns a pointer to the event if it is of type T, otherwise
 * nullptr.
 *
 * All event types must inherit from va::event::EventBase (enforced by the macros).
 * Thread-safe unique ID generation is ensured via std::atomic.
 */

#ifndef _VAEVENT_HPP_
#define _VAEVENT_HPP_

#include <atomic>
#include <stdlib.h>

// return a unique id number
inline std::atomic< size_t >& global_id_counter()
{
    static std::atomic< size_t > counter{ 0 };
    return counter;
}

// get the type id of a type
template < typename T > size_t event_type_id()
{
    static size_t id = global_id_counter()++;
    return id;
}

// must be included in new event's definition.
#define EVENT_BASE_METHOD( T )       \
    size_t id() const override       \
    {                                \
        return event_type_id< T >(); \
    }

// but you can also use this to simply define a event
#define VA_EVENT_DEFINE( EventName )               \
    struct EventName : public va::event::EventBase \
    {                                              \
        EVENT_BASE_METHOD( EventName );

#define VA_EVENT_DEFINE_END \
    }                       \
    ;

namespace va
{
namespace event
{
    struct EventBase
    {
        virtual ~EventBase()      = default;
        virtual size_t id() const = 0;
    };

    template < typename T > constexpr bool is_event( const EventBase& e )
    {
        return e.id() == event_type_id< T >();
    }

    template < typename T > const T* getIf( const EventBase& e )
    {
        if ( is_event< T >( e ) )
            {
                return &static_cast< const T& >( e );
            }
        return nullptr;
    }
}
}
#endif
#ifndef _VA_EVENTROUTER_HPP_
#define _VA_EVENTROUTER_HPP_

#include "VaEventUpstream.hpp"

#include <memory>
#include <queue>

namespace va
{

/// Register, absorb, and dispatch events
class VaEventRouter : public VaEventUpstream
{
  protected:
    // Buffer for events from various sources
    // Using smart pointers for memory safety
    std::queue< std::shared_ptr< event::EventBase > > EventBuffer;

  public:
    // Push an event into the buffer
    bool Push( std::shared_ptr< event::EventBase > event );

    // Dispatch one event from the buffer
    void DispatchOnce() override;
    void thr_DispatchLoop() override;

    VaEventRouter() : VaEventUpstream() {};

    ~VaEventRouter()
    {
        eventloopStop();
    }
};

}  // namespace va

#endif
#ifndef _VA_EVENTUPSTREAM_HPP_
#define _VA_EVENTUPSTREAM_HPP_

#include "VaEntity.hpp"
#include "entity_Wptr.hpp"

#include <atomic>
#include <condition_variable>
#include <mutex>
#include <thread>
#include <unordered_map>
#include <vector>

namespace va
{

/// for event dispatching
class VaEventUpstream
{
  protected:
    std::mutex              mtx,cv_mtx;
    std::condition_variable cv;
    std::atomic< bool >     running{ false };
    std::thread             eventThread;

    /*
    Establish two indexes for registrants and events:
    One using event indexing for efficient event distribution
    One using entity indexing for efficient entity deregistration
    */
    // Store listeners indexed by event ID
    std::vector< std::vector< entity_Wptr > > Listeners;
    // For quick lookup of events registered by specific entities
    std::unordered_map< entity_Sptr, std::vector< size_t > > Listeners2;

  public:
    // Register an entity to listen for a specific event
    void Register( size_t event_id, entity_Sptr entity );

    // Dispatch one event from the buffer
    virtual void DispatchOnce() = 0;

    // Event loop running in a separate thread
    virtual void thr_DispatchLoop() = 0;

    /*
    Three different unregistration methods:
    Unregister an entity and all its registered events
    Unregister all entities from a specific event
    Unregister a specific event from a specific entity
    */
    void UnRegister( entity_Sptr entity );
    void UnRegister( size_t event_id );
    void UnRegister( entity_Sptr entity, size_t event_id );

    // Start/stop the dispatch loop thread
    void eventloopStart();
    void eventloopStop();

    // Check if the event loop is running
    bool IsRunning() const
    {
        return running;
    }

    VaEventUpstream()  = default;
    ~VaEventUpstream() = default;
};

}  // namespace va

#endif  // _VA_EVENTUPSTREAM_HPP_
#ifndef _VA_INPUT_HPP
#define _VA_INPUT_HPP

#include "core/VaEventUpstream.hpp"

VA_EVENT_DEFINE(VA_MOUSE_LEFT_CLICK)
    float x,y;
    int duration = -1; // time_t i


namespace va
{
class VaInput
{
protected:

    

public:

    // Start or Stop mouse loop 
    void Start();
    void Stop();

};
}

#endif  //_VA_INPUT_HPP
